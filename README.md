# 3
deque - это обобщение стеков и очередей. Является частью библиотеки collections.

append(x) Добавьте x в правую часть deque.
appendleft(x) Добавьте x в левую часть deque.
clear() Удалите все элементы из deque, оставив ее длиной 0.
copy() Создайте копию deque.
count(x) Количество элементов deque, равное x.
extend(iterable) Расширьте правую часть deque, добавив элементы из итерируемого аргумента.
extendleft(iterable) Расширьте левую часть deque, добавив элементы из iterable. Обратите внимание, что серия левых добавлений приводит к обратному порядку элементов в итерируемом аргументе.
index(x[, start[, stop]]) Возвращает позицию x в deque (в начале или после начала индекса и перед остановкой индекса). Возвращает первое совпадение или вызывает ValueError, если не найдено.
insert(i, x) Вставьте x в deque в позиции i.
pop() Удалить и вернуть элемент с правой стороны deque. Если элементов нет, вызывает IndexError.
popleft() Удалить и вернуть элемент с левой стороны deque. Если элементов нет, вызывает IndexError.
remove(value) Удалить первое вхождение значения. Если не найден, вызывает ValueError.
reverse() Инвертируйте элементы deque на месте, а затем верните None.
rotate(n=1) Повернуть очередь на n шагов вправо. Если n отрицательно, повернуть влево.
deque поддерживают потокобезопасные, эффективно использующие память операции добавления и извлечения с любой стороны двухсторонней очереди с примерно одинаковой производительностью O(1) в любом направлении.

ChainMap группирует несколько словарей или других сопоставлений вместе, чтобы создать единое обновляемое представление. Если сопоставления не указаны, предоставляется один пустой словарь, так что новая цепочка всегда имеет хотя бы одно сопоставление. Является частью библиотеки collections.
Поддерживаются все обычные методы словаря. Кроме того, есть атрибут maps, метод для создания новых подконтекстов и свойство для доступа ко всем сопоставлениям, кроме первого:
maps Обновляемый пользователем список сопоставлений. Список упорядочен от первого к последнему поиску. Это единственное сохраненное состояние, и его можно изменить, чтобы изменить поиск сопоставлений. Список всегда должен содержать хотя бы одно сопоставление.
Базовые сопоставления хранятся в списке. Этот список является общедоступным, и его можно просмотреть или обновить с помощью атрибута карты. Другого государства нет.
Поиск последовательно выполняет поиск базовых сопоставлений, пока не будет найден ключ. Напротив, записи, обновления и удаления работают только с первым сопоставлением.

UserList класс действует как оболочка для объектов list. Это полезный базовый класс для ваших собственных классов, подобных спискам, которые могут наследоваться от них и переопределять существующие методы или добавлять новые. Таким образом, в списки можно добавлять новые модели поведения. Является частью библиотеки collections.
В дополнение к поддержке методов и операций изменяемых последовательностей экземпляры UserList предоставляют следующий атрибут:
data Настоящий объект списка, используемый для хранения содержимого класса UserList.
Требования к подклассам: ожидается, что подклассы UserList будут предлагать конструктор, который можно вызывать либо без аргументов, либо с одним аргументом. Операции списка, которые возвращают новую последовательность, пытаются создать экземпляр фактического класса реализации. Для этого предполагается, что конструктор может быть вызван с одним параметром, который является объектом последовательности, используемым в качестве источника данных. Если производный класс не хочет соответствовать этому требованию, все специальные методы, поддерживаемые этим классом, должны быть переопределены; пожалуйста, обратитесь к источникам для получения информации о методах, которые должны быть предоставлены в этом случае.

Класс UserDict действует как оболочка для объектов словаря. Потребность в этом классе была частично вытеснена возможностью создавать подклассы непосредственно из dict; однако с этим классом может быть проще работать, поскольку базовый словарь доступен как атрибут. Является частью библиотеки collections.
В дополнение к поддержке методов и операций сопоставлений экземпляры UserDict предоставляют следующий атрибут:
data Настоящий словарь, используемый для хранения содержимого класса UserDict.
Класс, имитирующий словарь. Содержимое экземпляра хранится в обычном словаре, который доступен через атрибут данных экземпляров UserDict. Если предоставлены начальные данные, данные инициализируются со своим содержимым; обратите внимание, что ссылка на начальные данные не будет сохранена, что позволит использовать ее для других целей.

UserString действует как оболочка строковых объектов. Потребность в этом классе была частично вытеснена возможностью создавать подклассы непосредственно из str; однако с этим классом может быть проще работать, поскольку базовая строка доступна как атрибут. Является частью библиотеки collections.
Помимо поддержки методов и операций строк, экземпляры UserString предоставляют следующий атрибут:
data Настоящий объект str, используемый для хранения содержимого класса UserString.
Класс, имитирующий строковый объект. Содержимое экземпляра хранится в обычном строковом объекте, который доступен через атрибут данных экземпляров UserString. Содержимое экземпляра изначально устанавливается на копию seq. Аргументом seq может быть любой объект, который можно преобразовать в строку с помощью встроенной функции str().

Frozendict — это неизменяемая оболочка для словарей, которая реализует полный интерфейс сопоставления. Его можно использовать в качестве замены словарям, где требуется неизменность.
Конечно, это python, и вы все еще можете ковыряться во внутренностях объекта, если хотите.
Конструктор Frozendict имитирует dict и предоставляет все ожидаемые интерфейсы (iter, len, repr, hash, getitem). Обратите внимание, что заморозка не гарантирует неизменности своих значений, поэтому полезность метода хеширования ограничена использованием.
Единственная разница заключается в том, что метод copy() для Frozendict принимает переменные аргументы ключевого слова, которые будут представлены в виде пар ключ/значение в новой неизменной копии.
